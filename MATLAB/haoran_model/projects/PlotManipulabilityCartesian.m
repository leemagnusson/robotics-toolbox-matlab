%% Plot Manipulability ellipsoid of the cartesian arm in its work space
% This script plots the manipulability ellipsoid of the cartesian arm for
% translation and rotation separately in its work space. The work space is
% generated by sweeping joint 1 to 5 within their joint limits.
%%
clc
clear all
close all
load('urdf_info_1.0.mat')
load('vertex_arm_origin_1.0.mat')
load('arm_version_1.0.mat')
load('coupling_matrix.mat')
transformation_base=eye(4);
% setup arm
q=[0,0,0,0,0,0,0,0,0,0,0]';
robot_object.transformation_base_ = eye(4);
robot_object.CalculateFK(q);
h1 = figure(1);
hold on
view(46,23)
axis equal
robot_object.DrawRobot(vertex_arm_origin);
hold on
light('Position',[1 3 2]);
light('Position',[-3 -1 -3]);
axis([-1.2 1.2 -1.2 1.2 -1.2 1.2]);
grid on
grid minor

h2 = figure(2);
hold on
view(46,23)
axis equal
robot_object.DrawRobot(vertex_arm_origin);
hold on
light('Position',[1 3 2]);
light('Position',[-3 -1 -3]);
axis([-1.2 1.2 -1.2 1.2 -1.2 1.2]);
grid on
grid minor

joint_limits = [robot_object.joint_limit_(:,2) robot_object.joint_limit_(:,3) robot_object.joint_limit_(:,4) robot_object.joint_limit_(:,5) robot_object.joint_limit_(:,6) [-pi;pi]];
v_max = 0.1;
omega_max = 1;
num_data = 1;
sample_step = 30*pi/180;
for q1 = joint_limits(1,1):sample_step:joint_limits(2,1)
    for q2 = joint_limits(1,2):sample_step:joint_limits(2,2)
        for q3 = joint_limits(1,3):sample_step:joint_limits(2,3)
            for q4 = joint_limits(1,4):sample_step:joint_limits(2,4)
                for q5 = joint_limits(1,5):sample_step:joint_limits(2,5)
                    %                         for q6 = joint_limits(1,6):(3*sample_step):joint_limits(2,6)
                    for q6 = 0
%                         num_data
                        q=[q1,q2,q3,q4,q5,q6,0,0,0,0,0]';
%                         q=[0,0,0,0,0,0,0,0,0,0,0]';
                        robot_object.CalculateFK(q);
                        [jacobian_spherical,jacobian_cartesian,jacobian_all] = robot_object.CalculateJacobianAll;
                        jacobian_6DoF_car = jacobian_all(:,1:6);
                        [u1_matrix,e1_matrix,v1_matrix] = svd(jacobian_6DoF_car(1:3,:));
                        condition_number_translation(num_data) = e1_matrix(1,1)/e1_matrix(3,3);
                        [u2_matrix,e2_matrix,v2_matrix] = svd(jacobian_6DoF_car(4:6,:));
                        condition_number_rotation(num_data) = e2_matrix(1,1)/e2_matrix(3,3);
                        
                        rcm_store(:,num_data) = robot_object.frames_(1:3,4,7);
                        q_store(:,num_data) = q;
                        jacobian_pinv = pinv(jacobian_6DoF_car);
                        jacobian_pinv_1 = jacobian_pinv(1:3,1:3);
                        jacobian_pinv_2 = jacobian_pinv(1:3,4:6);
                        jacobian_pinv_3 = jacobian_pinv(4:6,1:3);
                        jacobian_pinv_4 = jacobian_pinv(4:6,4:6);
                        
%                         q_dot1 = pinv(jacobian_6DoF_car) * [v_max * u1_matrix(:,1);zeros(3,1)];
%                         q_dot2 = pinv(jacobian_6DoF_car) * [v_max * u1_matrix(:,2);zeros(3,1)];
%                         q_dot3 = pinv(jacobian_6DoF_car) * [v_max * u1_matrix(:,3);zeros(3,1)];
                        q_dot1_translation = [jacobian_pinv_1;jacobian_pinv_3] * v_max * u1_matrix(:,1);
                        q_dot2_translation = [jacobian_pinv_1;jacobian_pinv_3] * v_max * u1_matrix(:,2);
                        q_dot3_translation = [jacobian_pinv_1;jacobian_pinv_3] * v_max * u1_matrix(:,3);
                        q_dot_translation = [q_dot1_translation q_dot2_translation q_dot3_translation];
                        q_dot_max_translation = [max(abs(q_dot_translation(1,:)));max(abs(q_dot_translation(2,:)));max(abs(q_dot_translation(3,:)));max(abs(q_dot_translation(4,:)));max(abs(q_dot_translation(5,:)));max(abs(q_dot_translation(6,:)))];
%                         q_dot1 = pinv(jacobian_6DoF_car) * [zeros(3,1);omega_max * u2_matrix(:,1)];
%                         q_dot2 = pinv(jacobian_6DoF_car) * [zeros(3,1);omega_max * u2_matrix(:,2)];
%                         q_dot3 = pinv(jacobian_6DoF_car) * [zeros(3,1);omega_max * u2_matrix(:,3)];
                        q_dot1_rotation = [jacobian_pinv_2;jacobian_pinv_4] * omega_max * u2_matrix(:,1);
                        q_dot2_rotation = [jacobian_pinv_2;jacobian_pinv_4] * omega_max * u2_matrix(:,2);
                        q_dot3_rotation = [jacobian_pinv_2;jacobian_pinv_4] * omega_max * u2_matrix(:,3);
                        q_dot_rotation = [q_dot1_rotation q_dot2_rotation q_dot3_rotation];
                        q_dot_max_rotation = [max(abs(q_dot_rotation(1,:)));max(abs(q_dot_rotation(2,:)));max(abs(q_dot_rotation(3,:)));max(abs(q_dot_rotation(4,:)));max(abs(q_dot_rotation(5,:)));max(abs(q_dot_rotation(6,:)))];
                        
                        max_joint_velocity_translation_store(:,num_data) = q_dot_max_translation;
                        max_joint_velocity_rotation_store(:,num_data) = q_dot_max_rotation;
                        set(0,'CurrentFigure',h1)
                        DrawManipulabilityEllipse(e1_matrix,u1_matrix,robot_object.frames_(1:3,4,7),0.02)
                        hold on
                        set(0,'CurrentFigure',h2)
                        DrawManipulabilityEllipse(e2_matrix,u2_matrix,robot_object.frames_(1:3,4,7),0.02)
                        hold on
                        num_data = num_data + 1;
                    end
                end
            end
        end
    end
end
set(0,'CurrentFigure',h1)
drawnow;
set(0,'CurrentFigure',h2)
drawnow;
% save('../export/cartesian_max_joint_velocity.mat','condition_number_translation','condition_number_rotation','rcm_store','q_store','max_joint_velocity_translation_store','max_joint_velocity_rotation_store')
